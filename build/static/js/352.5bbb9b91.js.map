{"version":3,"file":"static/js/352.5bbb9b91.js","mappings":"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","sources":["controllers/hls/HLSUtils.js","controllers/hls/HLSController.js","layouts/HLSView.jsx"],"sourcesContent":["/**\n *\n * @param {Array[][]} tagList are the fragment tags sent\n * from backend. Their follow the following structure\n * [\n *  [\n *    \"INF\",\n *    \"2\"\n *  ],\n *  [\n *    \"EXT-PROGRAM-TIME\",\n *    \"2022-07-01T08:41:46+0000\"\n *  ],\n *  [\n *    \"EXT-DATE-RANGE\",\n *    \"somethignsomething;duration='2';payload='Hello'\"\n *  ]\n * ]\n * @returns an object with parsed tags. Original\n * tags are available in rawTags property as Key/Value pairs.\n */\nexport function parseTagsList(tagList) {\n  const tagMap = {};\n  for (const tags of tagList) {\n    if (tagMap[tags[0]]) {\n      tagMap[tags[0]].push(removeQuotes(tags[1]));\n    } else {\n      tagMap[tags[0]] = [removeQuotes(tags[1])];\n    }\n  }\n\n  const result = {\n    rawTags: {\n      ...tagMap,\n    },\n    duration: Number(tagMap[\"INF\"][0]),\n    fragmentStartAt: tagMap[\"PROGRAM-DATE-TIME\"]\n      ? new Date(tagMap[\"PROGRAM-DATE-TIME\"][0])\n      : undefined,\n  };\n  return result;\n}\n\n/**\n *\n * @param {string} metadatastring the raw EXT-X-DATERANGE value\n * @returns an object of parsed data.\n */\nexport function parseAttributesFromMetadata(metadatastring) {\n  const metadataAttributes = metadatastring.split(\",\");\n\n  const attributesByKey = {};\n  for (const attribute of metadataAttributes) {\n    const [attribKey, attribValue] = attribute.split(\"=\");\n    attributesByKey[attribKey] = removeQuotes(attribValue);\n  }\n\n  return {\n    duration: attributesByKey[\"DURATION\"],\n    id: attributesByKey[\"ID\"],\n    startTime: new Date(attributesByKey[\"START-DATE\"]),\n    payload: attributesByKey[\"X-100MSLIVE-PAYLOAD\"],\n  };\n}\n\n/**\n *\n * @param {Date} time\n * @returns total seconds from 00:00:00 to 'time'\n */\nexport function getSecondsFromTime(time) {\n  if (time) {\n    return (\n      time.getHours() * 60 * 60 + time.getMinutes() * 60 + time.getSeconds()\n    );\n  }\n}\n\nexport function isAlreadyInMetadataMap(fragsTimeStamps, tagMetadata) {\n  const alreadyExistingmetadata = fragsTimeStamps.filter(\n    fragsTimeStamp => fragsTimeStamp.id === tagMetadata.id\n  );\n\n  return !!alreadyExistingmetadata.length;\n}\n\n/**\n * Removes qoutes in string.\n * (e.g) removeQoutes('Hello \"Ram\"!') // returns 'hello Ram!'\n * @param {string} str - string to remove the qoutes from.\n * @returns\n */\nfunction removeQuotes(str) {\n  return str.replace(/^\"(.*)\"$/, \"$1\");\n}\n","import Hls from \"hls.js\";\nimport { EventEmitter2 as EventEmitter } from \"eventemitter2\";\nimport { FeatureFlags } from \"../../services/FeatureFlags\";\nimport {\n  getSecondsFromTime,\n  isAlreadyInMetadataMap,\n  parseAttributesFromMetadata,\n  parseTagsList,\n} from \"./HLSUtils\";\n\nexport const HLS_TIMED_METADATA_LOADED = \"hls-timed-metadata\";\nexport const HLS_STREAM_NO_LONGER_LIVE = \"hls-stream-no-longer-live\";\nexport const HLS_DEFAULT_ALLOWED_MAX_LATENCY_DELAY = 10; // seconds\n\nexport class HLSController {\n  hls;\n  videoRef;\n  metadataByTimeStamp = new Map();\n  eventEmitter = new EventEmitter();\n  isLive = true;\n  constructor(hlsUrl, videoRef) {\n    this.hls = new Hls(this.getHLSConfig());\n    this.videoRef = videoRef;\n    this.hls.loadSource(hlsUrl);\n    this.hls.attachMedia(videoRef.current);\n    this.handleHLSTimedMetadataParsing();\n    this.ControllerEvents = [\n      HLS_TIMED_METADATA_LOADED,\n      HLS_STREAM_NO_LONGER_LIVE,\n    ];\n  }\n\n  reset() {\n    if (this.hls && this.hls.media) {\n      this.hls.detachMedia();\n      this.hls = null;\n    }\n    this.metadataByTimeStamp = null;\n    this.eventEmitter = null;\n  }\n\n  /**\n   *\n   * @returns returns a Number which represents current\n   * quality level. -1 if currentlevel is set to \"Auto\"\n   */\n  getCurrentLevel() {\n    return this.hls.currentLevel;\n  }\n\n  /**\n   *\n   * @param { Number } currentLevel - currentLevel we want to\n   * set the stream to. -1 for Auto\n   */\n  setCurrentLevel(currentLevel) {\n    this.hls.currentLevel = currentLevel;\n  }\n\n  jumpToLive() {\n    const videoEl = this.videoRef.current;\n    videoEl.currentTime = this.hls.liveSyncPosition;\n    if (videoEl.paused) {\n      try {\n        videoEl.play();\n      } catch (err) {\n        console.error(\"Attempt to jump to live position Failed.\", err);\n      }\n    }\n  }\n\n  /**\n   * Event listener. Also takes HLS JS events. If its\n   * not a Controller's event, it just forwards the\n   * request to hlsjs\n   * @param {string | Hls.Events} eventName\n   * @param {Function} eventCallback\n   */\n  on(eventName, eventCallback) {\n    /**\n     * slight optimization. If the user is not\n     * interested in HLS_STREAM_NO_LONGER_LIVE,\n     * we don't have to register time_update event\n     * as it is a bit costly.\n     */\n    if (eventName === HLS_STREAM_NO_LONGER_LIVE) {\n      this.enableTimeUpdateListener();\n    }\n    if (this.ControllerEvents.indexOf(eventName) === -1) {\n      this.hls.on(eventName, eventCallback);\n    } else {\n      this.eventEmitter.addListener(eventName, eventCallback);\n    }\n  }\n\n  // listen for pause, play as well to show not live if paused\n  enableTimeUpdateListener() {\n    this.videoRef.current.addEventListener(\"timeupdate\", _ => {\n      if (this.hls) {\n        const videoEl = this.videoRef.current;\n        const allowedDelay =\n          this.getHLSConfig().liveMaxLatencyDuration ||\n          HLS_DEFAULT_ALLOWED_MAX_LATENCY_DELAY;\n        this.isLive =\n          this.hls.liveSyncPosition - videoEl.currentTime <= allowedDelay;\n        if (!this.isLive) {\n          this.eventEmitter.emit(HLS_STREAM_NO_LONGER_LIVE);\n        }\n      }\n    });\n  }\n  handleHLSTimedMetadataParsing() {\n    /**\n     * Everytime a fragment is appended to the buffer,\n     * we parse the tags and see if the metadata is\n     * in the tags. If it does, we parse the metadatastrings\n     * and create a metadataMap. This metadataMap is a map of key value\n     * pairs with timeinSeconds as key and the value is an array of objects\n     * of the parsed metadata.\n     * (e.g)\n     *  {\n     *   36206: [{\n     *     duration: \"20\",\n     *     id: \"c382fce1-d551-4862-bdb3-c255ca668154\",\n     *     payload: \"hello2572\",\n     *     startTime: Tue Jun 28 2022 10:03:26 GMT+0530 (India Standard Time)\n     *   }]\n     * }\n     */\n    this.hls.on(Hls.Events.BUFFER_APPENDED, (_, { frag }) => {\n      try {\n        const tagList = frag?.tagList;\n        const tagsMap = parseTagsList(tagList);\n        // There could be more than one EXT-X-DATERANGE tags in a fragment.\n        const metadataStrings = tagsMap.rawTags[\"EXT-X-DATERANGE\"] || [];\n        if (metadataStrings.length > 0) {\n          for (let metadataString of metadataStrings) {\n            const tagMetadata = parseAttributesFromMetadata(metadataString);\n            const timeSegment = getSecondsFromTime(tagMetadata.startTime);\n            /**\n             * a single timestamp can have upto 3 DATERANGE tags.\n             * so we accumulate everything into a single key such that\n             * <timesegment>: [mt1, mt2, mt3]\n             */\n            if (this.metadataByTimeStamp.has(timeSegment)) {\n              // entry already exist in metadatamap\n              const metadataByTimeStampEntries =\n                this.metadataByTimeStamp.get(timeSegment);\n\n              /**\n               * Backend will keep sending the same metadata tags in each fragments\n               * until the fragment programtime exceed metadata starttime. so to prevent\n               * same tags getting parsed into metadataMap, we do a quick check here.\n               */\n              if (\n                !isAlreadyInMetadataMap(metadataByTimeStampEntries, tagMetadata)\n              ) {\n                // append current metadata to existing timestamp\n                this.metadataByTimeStamp.get(timeSegment).push(tagMetadata);\n              }\n            } else {\n              // no entry in metadataMap exist. So add a new entry\n              this.metadataByTimeStamp.set(timeSegment, [\n                {\n                  ...tagMetadata,\n                },\n              ]);\n            }\n          }\n        }\n      } catch (e) {\n        console.error(\"Error in extracting timemetadata\", e);\n      }\n    });\n\n    /**\n     * on Every Fragment change, we check if the fragment's\n     * PROGRAM_TIME is nearby a possible metadata's START_TIME\n     * If it does, we start a setTimeout and try to emit an event\n     * on the right time.\n     * NOTE: Javascript cannot gaurantee exact time, it\n     * only gaurantees minimum time before trying to emit.\n     */\n    this.hls.on(Hls.Events.FRAG_CHANGED, (_, { frag }) => {\n      try {\n        const tagsList = parseTagsList(frag?.tagList);\n\n        const timeSegment = getSecondsFromTime(tagsList.fragmentStartAt);\n        const timeStamps = [];\n        this.metadataByTimeStamp.forEach((value, key) => {\n          timeStamps.push(key);\n        });\n\n        let nearestTimeStamp = timeSegment;\n        timeStamps.push(timeSegment);\n        timeStamps.sort();\n\n        const whereAmI = timeStamps.indexOf(timeSegment);\n        nearestTimeStamp = timeStamps[whereAmI + 1];\n\n        /**\n         * This check is if timestamp ends up on the\n         * end of the array after sorting. Meaning,\n         * there is no possible future events.\n         * Hence NearestTimeStamp will be undefined.\n         */\n        if (isNaN(nearestTimeStamp)) {\n          return;\n        }\n\n        /**\n         * at this point its gauranteed that we have a timesegment and a possible\n         * future event very close. We now take the difference between them.\n         * The difference must always be between 0(start of the fragment) and INF duration(end of the fragment)\n         * if it is not, then the metadata doesn't belong to this fragment and we leave it\n         * 'as-is' so future fragments can try to parse it.\n         *\n         * (e.g) timestamp => [5,11,12,15,20,22], duration = 2.\n         *\n         * Fragment1_timesegment = 11 => nearestTimeStamp=>11 => 11 - 11 = 0 (play at start of the fragment)\n         *\n         * Fragment2_timesegment = 14 => nearestTimeStamp=>15 => 15 - 14 = 1 (still inside duration.\n         * so play after 1 sec of the start of the fragment)\n         *\n         * Fragment3_timesegment = 15 => nearestTimeStamp=>20 => 20 - 15 = 5 (5 is greated than duration 2. so\n         * this does not belong to this fragment. ignore and move on to next fragment)\n         *\n         * Fragment4_timesegment = 19 => nearestTimeStamp=>20 => 20 - 19 = 1 (valid)\n         *\n         */\n\n        const timeDifference = nearestTimeStamp - timeSegment;\n        if (timeDifference >= 0 && timeDifference < tagsList.duration) {\n          const payload = this.metadataByTimeStamp\n            .get(nearestTimeStamp)\n            .map(metadata => metadata.payload);\n          /**\n           * we start a timeout for difference seconds.\n           * NOTE: Due to how setTimeout works, the time is only the minimum gauranteed\n           * time JS will wait before calling emit(). It's not guaranteed even\n           * for timeDifference = 0.\n           */\n          setTimeout(() => {\n            /**\n             * finally emit event letting the user know its time to\n             * do whatever they want with the payload\n             */\n            this.eventEmitter.emit(HLS_TIMED_METADATA_LOADED, payload);\n            /** we delete the occured events from the metadataMap. This is not\n             * needed for the operation. Just a bit of optimisation as a really\n             * long stream with many metadata can quickly make the metadataMap really big.\n             */\n            this.metadataByTimeStamp.delete(nearestTimeStamp);\n          }, timeDifference * 1000);\n        }\n      } catch (e) {\n        console.error(\"Frag changed event listener error:\", e);\n      }\n    });\n  }\n\n  getHLSConfig() {\n    if (FeatureFlags.optimiseHLSLatency()) {\n      // should reduce the latency by around 2-3 more seconds. Won't work well without good internet.\n      return {\n        enableWorker: true,\n        liveSyncDuration: 1,\n        liveMaxLatencyDuration: 5,\n        liveDurationInfinity: true,\n        highBufferWatchdogPeriod: 1,\n      };\n    }\n    return {\n      enableWorker: true,\n      maxBufferLength: 20,\n      backBufferLength: 10,\n    };\n  }\n}\n","import React, {\n  useEffect,\n  useRef,\n  Fragment,\n  useState,\n  useCallback,\n} from \"react\";\nimport Hls from \"hls.js\";\nimport { useHMSStore, selectHLSState } from \"@100mslive/react-sdk\";\nimport {\n  ChevronDownIcon,\n  ChevronUpIcon,\n  SettingsIcon,\n  RecordIcon,\n} from \"@100mslive/react-icons\";\nimport {\n  Box,\n  Button,\n  Dropdown,\n  Flex,\n  styled,\n  Text,\n  Tooltip,\n} from \"@100mslive/react-ui\";\nimport { ToastManager } from \"../components/Toast/ToastManager\";\nimport {\n  HLSController,\n  HLS_STREAM_NO_LONGER_LIVE,\n  HLS_TIMED_METADATA_LOADED,\n} from \"../controllers/hls/HLSController\";\n\nconst HLSVideo = styled(\"video\", {\n  h: \"100%\",\n  margin: \"0 auto\",\n  px: \"$10\",\n});\n\nlet hlsController;\nconst HLSView = () => {\n  const videoRef = useRef(null);\n  const hlsState = useHMSStore(selectHLSState);\n  const hlsUrl = hlsState.variants[0]?.url;\n  // console.log(\"HLS URL\", hlsUrl);\n  const [availableLevels, setAvailableLevels] = useState([]);\n  const [isVideoLive, setIsVideoLive] = useState(true);\n  const [currentSelectedQualityText, setCurrentSelectedQualityText] =\n    useState(\"\");\n  const [qualityDropDownOpen, setQualityDropDownOpen] = useState(false);\n\n  useEffect(() => {\n    if (videoRef.current && hlsUrl) {\n      if (Hls.isSupported()) {\n        hlsController = new HLSController(hlsUrl, videoRef);\n\n        hlsController.on(HLS_STREAM_NO_LONGER_LIVE, () => {\n          setIsVideoLive(false);\n        });\n        hlsController.on(HLS_TIMED_METADATA_LOADED, payload => {\n          console.log(\n            `%c Payload: ${payload}`,\n            \"color:#2b2d42; background:#d80032\"\n          );\n          ToastManager.addToast({\n            title: `Payload from timed Metadata ${payload}`,\n          });\n        });\n\n        hlsController.on(Hls.Events.MANIFEST_LOADED, (_, { levels }) => {\n          setAvailableLevels(levels);\n          setCurrentSelectedQualityText(\"Auto\");\n        });\n      } else if (\n        videoRef.current.canPlayType(\"application/vnd.apple.mpegurl\")\n      ) {\n        videoRef.current.src = hlsUrl;\n      }\n    }\n  }, [hlsUrl]);\n\n  useEffect(() => {\n    if (hlsController) {\n      return () => hlsController.reset();\n    }\n  }, []);\n\n  const qualitySelectorHandler = useCallback(\n    qualityLevel => {\n      if (hlsController) {\n        hlsController.setCurrentLevel(getCurrentLevel(qualityLevel));\n        const levelText =\n          qualityLevel.height === \"auto\" ? \"Auto\" : `${qualityLevel.height}p`;\n        setCurrentSelectedQualityText(levelText);\n      }\n    },\n    [availableLevels] //eslint-disable-line\n  );\n\n  /**\n   *\n   * @param {the current quality level clicked by the user. It is the level object } qualityLevel\n   * @returns an integer ranging from 0 to (availableLevels.length - 1).\n   * (e.g) if 4 levels are available, 0 is the lowest quality and 3 is the highest.\n   *\n   * This function is used rather than just using availableLevels.findIndex(quality) because, HLS gives the\n   * levels in reverse.\n   * (e.g) if available levels in the m3u8 are 360p,480p,720p,1080p,\n   *\n   * hls.levels gives us an array of level objects in the order [1080p,720p,480p,360p];\n   *\n   * so setting hls.currentLevel = availableLevels.getIndexOf(1080p) will set the stream to 360p instead of 1080p\n   * because availableLevels.getIndexOf(1080p) will give 0 but level 0 is 360p.\n   */\n  const getCurrentLevel = qualityLevel => {\n    if (qualityLevel.height === \"auto\") {\n      return -1;\n    }\n    const index = availableLevels.findIndex(\n      ({ url }) => url === qualityLevel.url\n    );\n\n    return availableLevels.length - 1 - index;\n  };\n\n  return (\n    <Fragment>\n      {hlsUrl ? (\n        <>\n          <Flex\n            align=\"center\"\n            justify=\"center\"\n            css={{ position: \"absolute\", right: \"$10\", zIndex: \"10\" }}\n          >\n            {hlsController ? (\n              <Button\n                variant=\"standard\"\n                css={{ marginRight: \"0.3rem\" }}\n                onClick={() => {\n                  hlsController.jumpToLive();\n                  setIsVideoLive(true);\n                }}\n                key=\"LeaveRoom\"\n                data-testid=\"leave_room_btn\"\n              >\n                <Tooltip title=\"Jump to Live\">\n                  <Flex>\n                    <RecordIcon\n                      color={isVideoLive ? \"#CC525F\" : \"FAFAFA\"}\n                      key=\"jumpToLive\"\n                    />\n                    Live\n                  </Flex>\n                </Tooltip>\n              </Button>\n            ) : null}\n            <Dropdown.Root\n              open={qualityDropDownOpen}\n              onOpenChange={value => setQualityDropDownOpen(value)}\n            >\n              <Dropdown.Trigger asChild data-testid=\"quality_selector\">\n                <Flex\n                  css={{\n                    color: \"$textPrimary\",\n                    borderRadius: \"$1\",\n                    cursor: \"pointer\",\n                    zIndex: 4,\n                    border: \"$space$px solid $textDisabled\",\n                    padding: \"$4\",\n                  }}\n                >\n                  <Tooltip title=\"Select Quality\">\n                    <Flex>\n                      <SettingsIcon />\n                      <Text variant=\"md\">{currentSelectedQualityText}</Text>\n                    </Flex>\n                  </Tooltip>\n\n                  <Box\n                    css={{ \"@lg\": { display: \"none\" }, color: \"$textDisabled\" }}\n                  >\n                    {qualityDropDownOpen ? (\n                      <ChevronUpIcon />\n                    ) : (\n                      <ChevronDownIcon />\n                    )}\n                  </Box>\n                </Flex>\n              </Dropdown.Trigger>\n              {availableLevels.length > 0 && (\n                <Dropdown.Content\n                  sideOffset={5}\n                  align=\"end\"\n                  css={{ height: \"auto\", maxHeight: \"$96\" }}\n                >\n                  <Dropdown.Item\n                    onClick={event =>\n                      qualitySelectorHandler({ height: \"auto\" })\n                    }\n                    css={{\n                      h: \"auto\",\n                      flexDirection: \"column\",\n                      flexWrap: \"wrap\",\n                      cursor: \"pointer\",\n                      alignItems: \"flex-start\",\n                    }}\n                    key=\"auto\"\n                  >\n                    <Text>Automatic</Text>\n                  </Dropdown.Item>\n                  {availableLevels.map(level => {\n                    return (\n                      <Dropdown.Item\n                        onClick={() => qualitySelectorHandler(level)}\n                        css={{\n                          h: \"auto\",\n                          flexDirection: \"column\",\n                          flexWrap: \"wrap\",\n                          cursor: \"pointer\",\n                          alignItems: \"flex-start\",\n                        }}\n                        key={level.url}\n                      >\n                        <Text>{`${level.height}p (${(\n                          Number(level.bitrate / 1024) / 1024\n                        ).toFixed(2)} Mbps)`}</Text>\n                      </Dropdown.Item>\n                    );\n                  })}\n                </Dropdown.Content>\n              )}\n            </Dropdown.Root>\n          </Flex>\n\n          <HLSVideo ref={videoRef} autoPlay controls playsInline />\n        </>\n      ) : (\n        <Flex align=\"center\" justify=\"center\" css={{ size: \"100%\", px: \"$10\" }}>\n          <Text variant=\"md\" css={{ textAlign: \"center\" }}>\n            Waiting for the Streaming to start...\n          </Text>\n        </Flex>\n      )}\n    </Fragment>\n  );\n};\n\nexport default HLSView;\n"],"names":[],"sourceRoot":""}